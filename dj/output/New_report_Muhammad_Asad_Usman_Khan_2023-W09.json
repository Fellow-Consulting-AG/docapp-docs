{
  "author": "Muhammad Asad Usman Khan",
  "week": "2023-W09",
  "total_commits": 32,
  "author_image": "https://avatars.githubusercontent.com/u/83513548?v=4",
  "commits": [
    {
      "sha": "f08b8616d719a27715032a1c6bf6cb758911b414",
      "message": "fd",
      "code_changes": "@@ -527,7 +527,7 @@ def get_closest_references(\n \n         average_distance = total_distance / len(distances_list)\n         for key, _ in distances_list:\n-            if _ < average_distance:\n+            if _ < average_distance or len(closest_references) < 3:\n                 closest_references.append(ref_tokens_dict[key])\n \n         # closest_reference = min(distances_list, key=distances_list.get)",
      "code_change_description": "In the get_closest_references function, the condition to add a reference to the closest_references list was modified. Now, a reference is added to the list if its distance is less than the average distance or if the list has less than 3 elements. This ensures that at least 3 references are returned, even if they are not very close to the input text.",
      "code_smell_rating": 4,
      "github_labels": ["refactoring"]
    },
    {
      "sha": "5d2f880cfb7a91e9019a2b8a125fcd2470599555",
      "message": "Merge pull request #801 from Fellow-Consulting-AG/stage\n\nStage",
      "code_changes": "@@ -165,7 +165,7 @@ def populate_custom_lines(document):\n     c_lines_text = list()\n     for page in document[\"pages\"]:\n         c_lines_text.append(page[\"customPageText\"])\n-    document[\"customText\"] = \" \".join(c_lines_text)\n+    #document[\"customText\"] = \" \".join(c_lines_text)\n \n     # for line in custom_lines:\n     #     print(line['text'])",
      "code_change_description": "The code has been commented out for the line that joins the custom page text from all pages into a single string and assigns it to the 'customText' key in the 'document' dictionary.",
      "code_smell_rating": 5,
      "github_labels": ["commented-out-code"]
    },
    {
      "sha": "1189c63d749e1828193aa941990e047703b0df36",
      "message": "Merge pull request #800 from Fellow-Consulting-AG/dev\n\nfd",
      "code_changes": "@@ -165,7 +165,7 @@ def populate_custom_lines(document):\n     c_lines_text = list()\n     for page in document[\"pages\"]:\n         c_lines_text.append(page[\"customPageText\"])\n-    document[\"customText\"] = \" \".join(c_lines_text)\n+    #document[\"customText\"] = \" \".join(c_lines_text)\n \n     # for line in custom_lines:\n     #     print(line['text'])",
      "code_change_description": "The code has been commented out for the line that joins the custom page text from all pages into a single string and assigns it to the 'customText' key in the 'document' dictionary.",
      "code_smell_rating": 5,
      "github_labels": ["commented-out-code"]
    },
    {
      "sha": "9d1023853db755af2a3017cc88468f46a6c1ea17",
      "message": "fd",
      "code_changes": "@@ -165,7 +165,7 @@ def populate_custom_lines(document):\n     c_lines_text = list()\n     for page in document[\"pages\"]:\n         c_lines_text.append(page[\"customPageText\"])\n-    document[\"customText\"] = \" \".join(c_lines_text)\n+    #document[\"customText\"] = \" \".join(c_lines_text)\n \n     # for line in custom_lines:\n     #     print(line['text'])",
      "code_change_description": "The code has been commented out for the line that joins the custom page text from all pages into a single string and assigns it to the 'customText' key in the 'document' dictionary.",
      "code_smell_rating": 5,
      "github_labels": ["commented-out-code"]
    },
    {
      "sha": "586c49c5c2216f67ed9db3513ee8c3c7489e4ca8",
      "message": "Merge pull request #799 from Fellow-Consulting-AG/stage\n\nStage",
      "code_changes": "@@ -61,6 +61,29 @@ def get_ocr_text(file):\n     return text\n \n \n+@sync_wrapper(module=\"ocr\")\n+def get_pages_to_ocr(file):\n+    \"\"\"\n+    Extract text using OCR with PDF Reader\n+    Args:\n+        file: write your description\n+    \"\"\"\n+    pages = []\n+    try:\n+        logger.info(\"Trying if document has e-text\")\n+        with fitz.open(file) as doc:\n+            for index, page in enumerate(doc):\n+                if not page_digitally_created(page):\n+                    pages.append(str(index+1))\n+\n+    except Exception as e:\n+        pages = []\n+        logger.error(\"OCR with fitz failed. Error -> \" + str(e))\n+\n+    pages = ','.join(pages)\n+    # logger.info(\"Extracted text: \" + text)\n+    return pages\n+\n @sync_wrapper(module=\"ocr\")\n def get_ocred_document(user, filepath, destination, force=False, improve_quality=False):\n     \"\"\"\n@@ -133,7 +156,7 @@ def __get_ocr_file(\n     \"\"\"\n \n     files = [(\"file\", (\"Rechnung.pdf\", open(file, \"rb\"), \"application/pdf\"))]\n-\n+    pages = get_pages_to_ocr(file)\n     token = user.get_subscription_token()\n \n     logger.info(\"Sending ocr request.\")\n@@ -143,7 +166,7 @@ def __get_ocr_file(\n             url=url_upload,\n             headers={\"Authorization\": f\"Bearer {token}\"},\n             files=files,\n-            data={\"force\": True, \"improve_quality\": improve_quality},\n+            data={\"force\": True, \"improve_quality\": improve_quality, \"pages\": pages},\n             timeout=300,\n         )\n     else:\n@@ -160,6 +183,7 @@ def __get_ocr_file(\n                 \"rotate\": False,\n                 \"blank_pages\": False,\n                 \"improve_quality\": improve_quality,\n+                \"pages\": pages,\n             },\n             timeout=300,\n         )",
      "code_change_description": "A new function 'get_pages_to_ocr' has been added to extract the page numbers of the PDF file that need to be OCR-ed. The extracted page numbers are then passed as a parameter to the OCR API request.",
      "code_smell_rating": 2,
      "github_labels": ["enhancement"]
    },
    {
      "sha": "e1e46336a13df21d8282b2bab30b579c34919364",
      "message": "Merge pull request #798 from Fellow-Consulting-AG/dev\n\nfd",
      "code_changes": "@@ -61,6 +61,29 @@ def get_ocr_text(file):\n     return text\n \n \n+@sync_wrapper(module=\"ocr\")\n+def get_pages_to_ocr(file):\n+    \"\"\"\n+    Extract text using OCR with PDF Reader\n+    Args:\n+        file: write your description\n+    \"\"\"\n+    pages = []\n+    try:\n+        logger.info(\"Trying if document has e-text\")\n+        with fitz.open(file) as doc:\n+            for index, page in enumerate(doc):\n+                if not page_digitally_created(page):\n+                    pages.append(str(index+1))\n+\n+    except Exception as e:\n+        pages = []\n+        logger.error(\"OCR with fitz failed. Error -> \" + str(e))\n+\n+    pages = ','.join(pages)\n+    # logger.info(\"Extracted text: \" + text)\n+    return pages\n+\n @sync_wrapper(module=\"ocr\")\n def get_ocred_document(user, filepath, destination, force=False, improve_quality=False):\n     \"\"\"\n@@ -133,7 +156,7 @@ def __get_ocr_file(\n     \"\"\"\n \n     files = [(\"file\", (\"Rechnung.pdf\", open(file, \"rb\"), \"application/pdf\"))]\n-\n+    pages = get_pages_to_ocr(file)\n     token = user.get_subscription_token()\n \n     logger.info(\"Sending ocr request.\")\n@@ -143,7 +166,7 @@ def __get_ocr_file(\n             url=url_upload,\n             headers={\"Authorization\": f\"Bearer {token}\"},\n             files=files,\n-            data={\"force\": True, \"improve_quality\": improve_quality},\n+            data={\"force\": True, \"improve_quality\": improve_quality, \"pages\": pages},\n             timeout=300,\n         )\n     else:\n@@ -160,6 +183,7 @@ def __get_ocr_file(\n                 \"rotate\": False,\n                 \"blank_pages\": False,\n                 \"improve_quality\": improve_quality,\n+                \"pages\": pages,\n             },\n             timeout=300,\n         )",
      "code_change_description": "A new function 'get_pages_to_ocr' has been added to extract the page numbers of the PDF file that need to be OCR-ed. The extracted page numbers are then passed as a parameter to the OCR API request.",
      "code_smell_rating": 2,
      "github_labels": ["enhancement"]
    },
    {
      "sha": "034a8541f4dd03d0c8ffa04d7a1ec6d3e75e38f2",
      "message": "fd",
      "code_changes": "@@ -190,7 +190,7 @@ def post(self):\n                     extract_tables\n                     and (\n                         not ocr_helper.is_doc_ocr(f.name)\n-                        or (force_ocr and ocr_helper.is_ocred_by_doc2(f.name))\n+                        or (force_ocr and not ocr_helper.is_ocred_by_doc2(f.name)) # no point in OCR again if already done with doc2\n                     )\n                     or improve_quality\n                 ):\n@@ -793,7 +793,7 @@ def post(self):\n                     abort(400, f\"document with doc_id {doc_id} not found\")\n                 # force_ocr = False\n                 if not ocr_helper.is_doc_ocr(ufile.name) or (\n-                    force_ocr and ocr_helper.is_ocred_by_doc2(ufile.name)\n+                    force_ocr and not ocr_helper.is_ocred_by_doc2(ufile.name)\n                 ):\n                     ocr_helper.ocr_document(\n                         user,",
      "code_change_description": "The code change involves modifying the condition for OCRing a document. Previously, if a document was already OCR'ed by doc2, it would be OCR'ed again if force_ocr was set to True. Now, if a document is already OCR'ed by doc2, it will not be OCR'ed again even if force_ocr is set to True.",
      "code_smell_rating": 3,
      "github_labels": ["refactor"]
    },
    {
      "sha": "f0d050e5f25046e2988120c2d769bd106aad2cf5",
      "message": "fd",
      "code_changes": "@@ -61,6 +61,29 @@ def get_ocr_text(file):\n     return text\n \n \n+@sync_wrapper(module=\"ocr\")\n+def get_pages_to_ocr(file):\n+    \"\"\"\n+    Extract text using OCR with PDF Reader\n+    Args:\n+        file: write your description\n+    \"\"\"\n+    pages = []\n+    try:\n+        logger.info(\"Trying if document has e-text\")\n+        with fitz.open(file) as doc:\n+            for index, page in enumerate(doc):\n+                if not page_digitally_created(page):\n+                    pages.append(str(index+1))\n+\n+    except Exception as e:\n+        pages = []\n+        logger.error(\"OCR with fitz failed. Error -> \" + str(e))\n+\n+    pages = ','.join(pages)\n+    # logger.info(\"Extracted text: \" + text)\n+    return pages\n+\n @sync_wrapper(module=\"ocr\")\n def get_ocred_document(user, filepath, destination, force=False, improve_quality=False):\n     \"\"\"\n@@ -133,7 +156,7 @@ def __get_ocr_file(\n     \"\"\"\n \n     files = [(\"file\", (\"Rechnung.pdf\", open(file, \"rb\"), \"application/pdf\"))]\n-\n+    pages = get_pages_to_ocr(file)\n     token = user.get_subscription_token()\n \n     logger.info(\"Sending ocr request.\")\n@@ -143,7 +166,7 @@ def __get_ocr_file(\n             url=url_upload,\n             headers={\"Authorization\": f\"Bearer {token}\"},\n             files=files,\n-            data={\"force\": True, \"improve_quality\": improve_quality},\n+            data={\"force\": True, \"improve_quality\": improve_quality, \"pages\": pages},\n             timeout=300,\n         )\n     else:\n@@ -160,6 +183,7 @@ def __get_ocr_file(\n                 \"rotate\": False,\n                 \"blank_pages\": False,\n                 \"improve_quality\": improve_quality,\n+                \"pages\": pages,\n             },\n             timeout=300,\n         )",
      "code_change_description": "A new function 'get_pages_to_ocr' has been added to extract the page numbers of the PDF file that need to be OCR-ed. The extracted page numbers are then passed as a parameter to the OCR API request.",
      "code_smell_rating": 2,
      "github_labels": ["enhancement"]
    },
    {
      "sha": "83b28aa7d5d5cc63d1efe3590df88c31c44486c0",
      "message": "Merge pull request #797 from Fellow-Consulting-AG/stage\n\nStage",
      "code_changes": "@@ -164,7 +164,10 @@ def __get_ocr_file(\n             timeout=300,\n         )\n     logger.debug(\"Ocr request response. \" + (res).text)\n-    dict = json.loads((res).text)\n+    if (res).text:\n+        dict = json.loads((res).text)\n+    else:\n+        dict = {}\n \n     if \"alreadyOCR\" in dict and dict[\"alreadyOCR\"]:\n         logger.error(\"Document is already OCR. Going to use original document\")",
      "code_change_description": "The code has been modified to handle the case where the OCR request response is empty. If the response is empty, an empty dictionary is returned. This is done to prevent the code from breaking when the OCR request response is empty.",
      "code_smell_rating": 3,
      "github_labels": ["bug"]
    },
    {
      "sha": "ab85b074b8df9c5924660ae596c798fe9f6e069c",
      "message": "Merge pull request #796 from Fellow-Consulting-AG/dev\n\nfd",
      "code_changes": "@@ -164,7 +164,10 @@ def __get_ocr_file(\n             timeout=300,\n         )\n     logger.debug(\"Ocr request response. \" + (res).text)\n-    dict = json.loads((res).text)\n+    if (res).text:\n+        dict = json.loads((res).text)\n+    else:\n+        dict = {}\n \n     if \"alreadyOCR\" in dict and dict[\"alreadyOCR\"]:\n         logger.error(\"Document is already OCR. Going to use original document\")",
      "code_change_description": "The code has been modified to handle the case where the OCR request response is empty. If the response is empty, an empty dictionary is returned. This is done to prevent the code from breaking when the OCR request response is empty.",
      "code_smell_rating": 3,
      "github_labels": ["bug"]
    },
    {
      "sha": "b54fed0aa7bd7c25ae70ad5b6ceac9efd5f6ecf5",
      "message": "fd",
      "code_changes": "@@ -164,7 +164,10 @@ def __get_ocr_file(\n             timeout=300,\n         )\n     logger.debug(\"Ocr request response. \" + (res).text)\n-    dict = json.loads((res).text)\n+    if (res).text:\n+        dict = json.loads((res).text)\n+    else:\n+        dict = {}\n \n     if \"alreadyOCR\" in dict and dict[\"alreadyOCR\"]:\n         logger.error(\"Document is already OCR. Going to use original document\")",
      "code_change_description": "The code has been modified to handle the case where the OCR request response is empty. If the response is empty, an empty dictionary is returned. This is done to prevent the code from breaking when the OCR request response is empty.",
      "code_smell_rating": 3,
      "github_labels": ["bug"]
    },
    {
      "sha": "798fb4f8bda13f05529b8ec4fa2d102ef1f62bf5",
      "message": "Merge pull request #795 from Fellow-Consulting-AG/stage\n\nStage",
      "code_changes": "@@ -112,10 +112,11 @@ def readjust_coordinates(page_image, coords, strip_dim, v_padding=0, h_padding=0\n \n     return (x1, y1, x2, y2)\n \n+\n def keep_within_normalized_range(value):\n     if value > 1:\n         value = 1\n     elif value < 0:\n         value = 0\n \n-    return value\n\\ No newline at end of file\n+    return value",
      "code_change_description": "The code defines a function 'keep_within_normalized_range' that takes a value and ensures it is within the range of 0 and 1. This is done by checking if the value is greater than 1 or less than 0, and if so, setting it to the closest boundary value.",
      "code_smell_rating": 2,
      "github_labels": ["boundary-checking"]
    },
    {
      "sha": "ef8b583d5d5269f33a2347c474764f786a2c4bbd",
      "message": "Merge pull request #794 from Fellow-Consulting-AG/dev\n\nfd",
      "code_changes": "@@ -13,13 +13,8 @@\n from helper import util\n from helper.layout import layout_fields_helper as lfh\n from logger import get_logger\n-from models import (\n-    AlchemyEncoder,\n-    ColumnValidationRules,\n-    DocumentTable,\n-    DocumentTableColumn,\n-    DocumentType,\n-)\n+from models import (AlchemyEncoder, ColumnValidationRules, DocumentTable,\n+                    DocumentTableColumn, DocumentType)\n \n logger = get_logger(\"document_table_settings\")\n \n@@ -146,7 +141,8 @@ def get(self):\n                     else dcvr.is_hidden\n                 end as is_hidden,\n                 dtc.org_id,\n-                dtc.column_type\n+                dtc.column_type,\n+                dtc.title\n \n             from\n                 document_table dt\n@@ -722,6 +718,7 @@ def get(self):\n \n aiparser = api.parser()\n aiparser.add_argument(\"id\", type=str, required=True, location=\"form\")\n+aiparser.add_argument(\"title\", type=str, required=False, location=\"form\")\n aiparser.add_argument(\"is_hidden\", type=str, required=False, location=\"form\")\n aiparser.add_argument(\"is_deleted\", type=str, required=False, location=\"form\")\n \n@@ -745,6 +742,7 @@ def post(self):\n             org_id = user.get_org_id()\n             request_data = request.form\n             id = request_data.get(\"id\", None)\n+            title = request_data.get(\"title\", None)\n             is_hidden = request_data.get(\"is_hidden\", None)\n             is_hidden = util.str_to_bool(is_hidden, None)\n \n@@ -762,6 +760,9 @@ def post(self):\n                 logger.info(\"Table Column <id> not found.\")\n                 return {\"success\": False, \"message\": \"Column not found.\"}\n \n+            if title is not None:\n+                table_column.title = title\n+\n             validation_rule: ColumnValidationRules = (\n                 db.session.query(ColumnValidationRules)\n                 .filter(",
      "code_change_description": "The code has been modified to allow updating the title of a document table column. A new argument 'title' has been added to the post method of the DocumentTableColumnSettings class to update the title of a column. If the 'title' argument is provided, the title of the column is updated in the database.",
      "code_smell_rating": 2,
      "github_labels": ["enhancement"]
    },
    {
      "sha": "bc0860fe7164b58d34503a7781f09afe93d222e0",
      "message": "fd",
      "code_changes": "@@ -718,6 +718,7 @@ def get(self):\n \n aiparser = api.parser()\n aiparser.add_argument(\"id\", type=str, required=True, location=\"form\")\n+aiparser.add_argument(\"title\", type=str, required=False, location=\"form\")\n aiparser.add_argument(\"is_hidden\", type=str, required=False, location=\"form\")\n aiparser.add_argument(\"is_deleted\", type=str, required=False, location=\"form\")\n \n@@ -741,6 +742,7 @@ def post(self):\n             org_id = user.get_org_id()\n             request_data = request.form\n             id = request_data.get(\"id\", None)\n+            title = request_data.get(\"title\", None)\n             is_hidden = request_data.get(\"is_hidden\", None)\n             is_hidden = util.str_to_bool(is_hidden, None)\n \n@@ -758,6 +760,9 @@ def post(self):\n                 logger.info(\"Table Column <id> not found.\")\n                 return {\"success\": False, \"message\": \"Column not found.\"}\n \n+            if title is not None:\n+                table_column.title = title\n+\n             validation_rule: ColumnValidationRules = (\n                 db.session.query(ColumnValidationRules)\n                 .filter(",
      "code_change_description": "In the given code, an optional 'title' parameter has been added to the POST request for updating a table column. If the 'title' parameter is provided, the title of the table column is updated with the new value. The code has been modified to handle this new parameter.",
      "code_smell_rating": 2,
      "github_labels": ["enhancement"]
    },
    {
      "sha": "f1d5cf80644fd1e10ca6f1488e15c6c5f911f08e",
      "message": "fd",
      "code_changes": "@@ -13,13 +13,8 @@\n from helper import util\n from helper.layout import layout_fields_helper as lfh\n from logger import get_logger\n-from models import (\n-    AlchemyEncoder,\n-    ColumnValidationRules,\n-    DocumentTable,\n-    DocumentTableColumn,\n-    DocumentType,\n-)\n+from models import (AlchemyEncoder, ColumnValidationRules, DocumentTable,\n+                    DocumentTableColumn, DocumentType)\n \n logger = get_logger(\"document_table_settings\")\n \n@@ -146,7 +141,8 @@ def get(self):\n                     else dcvr.is_hidden\n                 end as is_hidden,\n                 dtc.org_id,\n-                dtc.column_type\n+                dtc.column_type,\n+                dtc.title\n \n             from\n                 document_table dt",
      "code_change_description": "The code has been refactored to remove unused imports and improve code readability by using aliases for imported modules. Additionally, the SELECT statement in the SQL query has been modified to include the 'title' field from the 'DocumentTableColumn' table.",
      "code_smell_rating": 3,
      "github_labels": ["refactor", "readability"]
    },
    {
      "sha": "dc8f10bc1f3720d654786ac2b1edb784a65b6b63",
      "message": "Merge pull request #793 from Fellow-Consulting-AG/stage\n\nStage",
      "code_changes": "@@ -105,9 +105,17 @@ def readjust_coordinates(page_image, coords, strip_dim, v_padding=0, h_padding=0\n     if y1 > y2:\n         y1, y2 = y2, y1\n \n-    x1 = x1 + adj_x1 - h_padding\n-    y1 = y1 + adj_y1 - v_padding\n-    x2 = x2 - adj_x2 + h_padding\n-    y2 = y2 - adj_y2 + v_padding\n+    x1 = keep_within_normalized_range((x1 + adj_x1 - h_padding) / width)\n+    y1 = keep_within_normalized_range((y1 + adj_y1 - v_padding) / height)\n+    x2 = keep_within_normalized_range((x2 - adj_x2 + h_padding) / width)\n+    y2 = keep_within_normalized_range((y2 - adj_y2 + v_padding) / height)\n \n-    return (x1 / width, y1 / height, x2 / width, y2 / height)\n+    return (x1, y1, x2, y2)\n+\n+def keep_within_normalized_range(value):\n+    if value > 1:\n+        value = 1\n+    elif value < 0:\n+        value = 0\n+\n+    return value\n\\ No newline at end of file",
      "code_change_description": "The code has been modified to ensure that the coordinates returned are within the normalized range of 0 to 1. The function 'keep_within_normalized_range' has been added to check if the value is within the range and return the value accordingly.",
      "code_smell_rating": 3,
      "github_labels": ["normalized-range"]
    },
    {
      "sha": "a26ac0e18c1fa97757be98225b2d8403a151fa38",
      "message": "Merge pull request #792 from Fellow-Consulting-AG/dev\n\nfd",
      "code_changes": "@@ -105,9 +105,17 @@ def readjust_coordinates(page_image, coords, strip_dim, v_padding=0, h_padding=0\n     if y1 > y2:\n         y1, y2 = y2, y1\n \n-    x1 = x1 + adj_x1 - h_padding\n-    y1 = y1 + adj_y1 - v_padding\n-    x2 = x2 - adj_x2 + h_padding\n-    y2 = y2 - adj_y2 + v_padding\n+    x1 = keep_within_normalized_range((x1 + adj_x1 - h_padding) / width)\n+    y1 = keep_within_normalized_range((y1 + adj_y1 - v_padding) / height)\n+    x2 = keep_within_normalized_range((x2 - adj_x2 + h_padding) / width)\n+    y2 = keep_within_normalized_range((y2 - adj_y2 + v_padding) / height)\n \n-    return (x1 / width, y1 / height, x2 / width, y2 / height)\n+    return (x1, y1, x2, y2)\n+\n+def keep_within_normalized_range(value):\n+    if value > 1:\n+        value = 1\n+    elif value < 0:\n+        value = 0\n+\n+    return value\n\\ No newline at end of file",
      "code_change_description": "The code has been modified to ensure that the coordinates returned are within the normalized range of 0 to 1. The function 'keep_within_normalized_range' has been added to check if the value is within the range and return the value accordingly.",
      "code_smell_rating": 3,
      "github_labels": ["normalized-range"]
    },
    {
      "sha": "ffb076e297e94e866315c3fb465bbf3d861df75f",
      "message": "fd",
      "code_changes": "@@ -105,9 +105,17 @@ def readjust_coordinates(page_image, coords, strip_dim, v_padding=0, h_padding=0\n     if y1 > y2:\n         y1, y2 = y2, y1\n \n-    x1 = x1 + adj_x1 - h_padding\n-    y1 = y1 + adj_y1 - v_padding\n-    x2 = x2 - adj_x2 + h_padding\n-    y2 = y2 - adj_y2 + v_padding\n+    x1 = keep_within_normalized_range((x1 + adj_x1 - h_padding) / width)\n+    y1 = keep_within_normalized_range((y1 + adj_y1 - v_padding) / height)\n+    x2 = keep_within_normalized_range((x2 - adj_x2 + h_padding) / width)\n+    y2 = keep_within_normalized_range((y2 - adj_y2 + v_padding) / height)\n \n-    return (x1 / width, y1 / height, x2 / width, y2 / height)\n+    return (x1, y1, x2, y2)\n+\n+def keep_within_normalized_range(value):\n+    if value > 1:\n+        value = 1\n+    elif value < 0:\n+        value = 0\n+\n+    return value\n\\ No newline at end of file",
      "code_change_description": "The code has been modified to ensure that the coordinates returned are within the normalized range of 0 to 1. The function 'keep_within_normalized_range' has been added to check if the value is within the range and return the value accordingly.",
      "code_smell_rating": 3,
      "github_labels": ["normalized-range"]
    },
    {
      "sha": "61c489da76ff9517a622ea0cd7680b0a841b115c",
      "message": "Merge pull request #791 from Fellow-Consulting-AG/stage\n\nStage",
      "code_changes": "@@ -59,6 +59,8 @@ def is_blank_image(image):\n     blackPxNum = np.count_nonzero([image <= 50])  # number of black pixels\n     whitePxNum = image.size - blackPxNum\n \n+    if image.size == 0:\n+        return True\n     black_percentage = (blackPxNum * 100) / image.size\n     white_percentage = (whitePxNum * 100) / image.size\n \n@@ -97,7 +99,7 @@ def readjust_coordinates(page_image, coords, strip_dim, v_padding=0, h_padding=0\n             int(y2 * height),\n         )\n     else:\n-        width, height = 1,1\n+        width, height = 1, 1\n     if x1 > x2:\n         x1, x2 = x2, x1\n     if y1 > y2:",
      "code_change_description": "The code has been modified to handle the case where the input image is empty. A check has been added to return True if the image size is 0.",
      "code_smell_rating": 2,
      "github_labels": ["bug"]
    },
    {
      "sha": "49079de74b5daac1db1ef982d8aa7560c3fad501",
      "message": "Merge pull request #790 from Fellow-Consulting-AG/dev\n\nfd",
      "code_changes": "@@ -59,6 +59,8 @@ def is_blank_image(image):\n     blackPxNum = np.count_nonzero([image <= 50])  # number of black pixels\n     whitePxNum = image.size - blackPxNum\n \n+    if image.size == 0:\n+        return True\n     black_percentage = (blackPxNum * 100) / image.size\n     white_percentage = (whitePxNum * 100) / image.size\n ",
      "code_change_description": "Added a check for empty image to avoid division by zero error.",
      "code_smell_rating": 2,
      "github_labels": ["bug"]
    },
    {
      "sha": "ae29d7599b2addc5cdb93de9e6d6172161677177",
      "message": "fd",
      "code_changes": "@@ -359,9 +359,29 @@ def get_adjusted_points_v2(page_proximity_data, field_point1, field_point2):\n         # if count > 2:\n         #     break\n \n-    return (adj1_x0 / count, adj1_y0 / count), (\n-        adj2_x0 / count,\n-        adj2_y0 / count,\n+    adj1_x0 = adj1_x0 / count\n+    if adj1_x0 < 0:\n+        adj1_x0 = 0\n+    elif adj1_x0 > 1:\n+        adj1_x0 = 1\n+    adj1_y0 = adj1_y0 / count\n+    if adj1_y0 < 0:\n+        adj1_y0 = 0\n+    elif adj1_y0 > 1:\n+        adj1_y0 = 1\n+    adj2_x0 = adj2_x0 / count\n+    if adj2_x0 < 0:\n+        adj2_x0 = 0\n+    elif adj2_x0 > 1:\n+        adj2_x0 = 1\n+    adj2_y0 = adj2_y0 / count\n+    if adj2_y0 < 0:\n+        adj2_y0 = 0\n+    elif adj2_y0 > 1:\n+        adj2_y0 = 1\n+    return (adj1_x0, adj1_y0), (\n+        adj2_x0,\n+        adj2_y0,\n     )\n \n ",
      "code_change_description": "The code has been modified to ensure that the adjusted points are within the range of 0 to 1. If the adjusted point is less than 0, it is set to 0 and if it is greater than 1, it is set to 1.",
      "code_smell_rating": 5,
      "github_labels": ["bug"]
    },
    {
      "sha": "13bc96001685a9b6faca2e31e7657eb540176644",
      "message": "fd",
      "code_changes": "@@ -59,6 +59,8 @@ def is_blank_image(image):\n     blackPxNum = np.count_nonzero([image <= 50])  # number of black pixels\n     whitePxNum = image.size - blackPxNum\n \n+    if image.size == 0:\n+        return True\n     black_percentage = (blackPxNum * 100) / image.size\n     white_percentage = (whitePxNum * 100) / image.size\n ",
      "code_change_description": "Added a check for empty image to avoid division by zero error.",
      "code_smell_rating": 2,
      "github_labels": ["bug"]
    },
    {
      "sha": "6a5e1786c3d9a9be967e9c2c77a13158b273b373",
      "message": "Merge pull request #789 from Fellow-Consulting-AG/stage\n\nStage",
      "code_changes": "@@ -151,6 +151,10 @@ def transform_ai_response(ai_resp_json):\n                             or nv0[\"x\"] < 0\n                             or nv2[\"y\"] < 0\n                             or nv0[\"y\"] < 0\n+                            or nv2[\"x\"] > 1\n+                            or nv0[\"x\"] > 1\n+                            or nv2[\"y\"] > 1\n+                            or nv0[\"y\"] > 1\n                             or nv2[\"x\"] < nv0[\"x\"]\n                             or nv2[\"y\"]\n                             < nv0[\"y\"]  # to remove garbage for table extraction",
      "code_change_description": "The code change added additional conditions to check if the coordinates of the vertices of a polygon are within the range of 0 to 1. This is to ensure that the polygon is within the bounds of the image. A code smell rating of 3 is assigned to this change as it improves the robustness of the code but could have been implemented in a more concise manner.",
      "code_smell_rating": 3,
      "github_labels": ["robustness"]
    },
    {
      "sha": "2fe15bfc206eed31d2bd1e70ba7bf73c0bff3224",
      "message": "Merge pull request #788 from Fellow-Consulting-AG/dev\n\nfd",
      "code_changes": "@@ -151,6 +151,10 @@ def transform_ai_response(ai_resp_json):\n                             or nv0[\"x\"] < 0\n                             or nv2[\"y\"] < 0\n                             or nv0[\"y\"] < 0\n+                            or nv2[\"x\"] > 1\n+                            or nv0[\"x\"] > 1\n+                            or nv2[\"y\"] > 1\n+                            or nv0[\"y\"] > 1\n                             or nv2[\"x\"] < nv0[\"x\"]\n                             or nv2[\"y\"]\n                             < nv0[\"y\"]  # to remove garbage for table extraction",
      "code_change_description": "The code change added additional conditions to check if the coordinates of the table are within the valid range of 0 to 1. This is to ensure that the table extraction process does not include any garbage data.",
      "code_smell_rating": 3,
      "github_labels": ["bug"]
    },
    {
      "sha": "91a515c6c88c5013c329a72b0ba58d48f0c21736",
      "message": "fd",
      "code_changes": "@@ -151,6 +151,10 @@ def transform_ai_response(ai_resp_json):\n                             or nv0[\"x\"] < 0\n                             or nv2[\"y\"] < 0\n                             or nv0[\"y\"] < 0\n+                            or nv2[\"x\"] > 1\n+                            or nv0[\"x\"] > 1\n+                            or nv2[\"y\"] > 1\n+                            or nv0[\"y\"] > 1\n                             or nv2[\"x\"] < nv0[\"x\"]\n                             or nv2[\"y\"]\n                             < nv0[\"y\"]  # to remove garbage for table extraction",
      "code_change_description": "The code change added additional conditions to check if the coordinates of the vertices of a polygon are within the range of 0 to 1. This is to ensure that the polygon is within the bounds of the image. A code smell rating of 3 is assigned to this change as it improves the robustness of the code but could have been implemented in a more concise manner.",
      "code_smell_rating": 3,
      "github_labels": ["robustness"]
    },
    {
      "sha": "cbf8e4ce2330e834fd682338a2cc3c96af6b7d89",
      "message": "Merge pull request #787 from Fellow-Consulting-AG/stage\n\nStage",
      "code_changes": "@@ -9,23 +9,14 @@\n from fellow2kv.extension import db, storagemanager\n from helpdesk import create_new_customer, create_ticket\n from helper import doc2_util\n-from helper.ai.ai_ocr import generate_hard_regex_from_string, generate_regex_from_string\n-from helper.util import (\n-    get_page,\n-    transform_from_normalized,\n-    transform_from_normalized_coords_object,\n-)\n+from helper.ai.ai_ocr import (generate_hard_regex_from_string,\n+                              generate_regex_from_string)\n+from helper.util import (get_page, transform_from_normalized,\n+                         transform_from_normalized_coords_object)\n from logger import get_logger\n-from models import (\n-    DocOriginRules,\n-    FellowKVRule,\n-    FellowKVRuleUser,\n-    FellowKVSourceFile,\n-    FellowKVTableColumnRule,\n-    FellowKVTableRule,\n-    TableFormattingRules,\n-    TfidfDocs,\n-)\n+from models import (DocOriginRules, FellowKVRule, FellowKVRuleUser,\n+                    FellowKVSourceFile, FellowKVTableColumnRule,\n+                    FellowKVTableRule, TableFormattingRules, TfidfDocs)\n \n logger = get_logger(\"plugin-export-util\")\n \n@@ -690,15 +681,18 @@ def create_table_rules_in_db(docs, user, is_new=False):\n                     )\n \n                     formatting_rules_id = str(uuid.uuid4())\n+                    rule_columns = rule.get(\"columns\", [\"\"])\n+                    if rule_columns == None:\n+                        rule_columns = [\"\"]\n                     if table_formatting_rule:\n                         formatting_rules_id = table_formatting_rule.id\n                         table_formatting_rule.ruleWeight = (\n                             table_formatting_rule.ruleWeight + 1\n                         )\n+                        table_formatting_rule.columns = rule_columns[0]\n+                        # update column locations because we dont use these in where clause\n+                        # so they didnt get updated on change.\n                     else:\n-                        rule_columns = rule.get(\"columns\", [\"\"])\n-                        if rule_columns == None:\n-                            rule_columns = [\"\"]\n                         table_formatting_rule = TableFormattingRules()\n                         table_formatting_rule.id = formatting_rules_id\n                         table_formatting_rule.docType = docType\n@@ -750,8 +744,8 @@ def create_table_rules_in_db(docs, user, is_new=False):\n                         table_formatting_rule.user_id = user_id\n                         table_formatting_rule.org_id = org_id\n                         db.session.add(table_formatting_rule)\n-                        db.session.commit()\n-                        db.session.refresh(table_formatting_rule)\n+                    db.session.commit()\n+                    db.session.refresh(table_formatting_rule)\n \n                 record = None\n                 if rule.get(\"rule_id\"):",
      "code_change_description": "Refactored import statements and removed unused imports. Also simplified some code blocks by removing unnecessary conditions and variables.",
      "code_smell_rating": 3,
      "github_labels": ["refactor"]
    },
    {
      "sha": "891d12237e8dfa29f6bf39f0e5424f77a7943c5a",
      "message": "Merge pull request #786 from Fellow-Consulting-AG/dev\n\nfd",
      "code_changes": "@@ -9,23 +9,14 @@\n from fellow2kv.extension import db, storagemanager\n from helpdesk import create_new_customer, create_ticket\n from helper import doc2_util\n-from helper.ai.ai_ocr import generate_hard_regex_from_string, generate_regex_from_string\n-from helper.util import (\n-    get_page,\n-    transform_from_normalized,\n-    transform_from_normalized_coords_object,\n-)\n+from helper.ai.ai_ocr import (generate_hard_regex_from_string,\n+                              generate_regex_from_string)\n+from helper.util import (get_page, transform_from_normalized,\n+                         transform_from_normalized_coords_object)\n from logger import get_logger\n-from models import (\n-    DocOriginRules,\n-    FellowKVRule,\n-    FellowKVRuleUser,\n-    FellowKVSourceFile,\n-    FellowKVTableColumnRule,\n-    FellowKVTableRule,\n-    TableFormattingRules,\n-    TfidfDocs,\n-)\n+from models import (DocOriginRules, FellowKVRule, FellowKVRuleUser,\n+                    FellowKVSourceFile, FellowKVTableColumnRule,\n+                    FellowKVTableRule, TableFormattingRules, TfidfDocs)\n \n logger = get_logger(\"plugin-export-util\")\n \n@@ -690,15 +681,18 @@ def create_table_rules_in_db(docs, user, is_new=False):\n                     )\n \n                     formatting_rules_id = str(uuid.uuid4())\n+                    rule_columns = rule.get(\"columns\", [\"\"])\n+                    if rule_columns == None:\n+                        rule_columns = [\"\"]\n                     if table_formatting_rule:\n                         formatting_rules_id = table_formatting_rule.id\n                         table_formatting_rule.ruleWeight = (\n                             table_formatting_rule.ruleWeight + 1\n                         )\n+                        table_formatting_rule.columns = rule_columns[0]\n+                        # update column locations because we dont use these in where clause\n+                        # so they didnt get updated on change.\n                     else:\n-                        rule_columns = rule.get(\"columns\", [\"\"])\n-                        if rule_columns == None:\n-                            rule_columns = [\"\"]\n                         table_formatting_rule = TableFormattingRules()\n                         table_formatting_rule.id = formatting_rules_id\n                         table_formatting_rule.docType = docType\n@@ -750,8 +744,8 @@ def create_table_rules_in_db(docs, user, is_new=False):\n                         table_formatting_rule.user_id = user_id\n                         table_formatting_rule.org_id = org_id\n                         db.session.add(table_formatting_rule)\n-                        db.session.commit()\n-                        db.session.refresh(table_formatting_rule)\n+                    db.session.commit()\n+                    db.session.refresh(table_formatting_rule)\n \n                 record = None\n                 if rule.get(\"rule_id\"):",
      "code_change_description": "Refactored import statements and removed unused imports. Also updated the logic for updating table formatting rules in the database.",
      "code_smell_rating": 3,
      "github_labels": ["refactor", "unused-imports"]
    },
    {
      "sha": "d86527a2e9bb29365563e82d3b3aa6d22df3928e",
      "message": "CLOU-4651",
      "code_changes": "@@ -9,23 +9,14 @@\n from fellow2kv.extension import db, storagemanager\n from helpdesk import create_new_customer, create_ticket\n from helper import doc2_util\n-from helper.ai.ai_ocr import generate_hard_regex_from_string, generate_regex_from_string\n-from helper.util import (\n-    get_page,\n-    transform_from_normalized,\n-    transform_from_normalized_coords_object,\n-)\n+from helper.ai.ai_ocr import (generate_hard_regex_from_string,\n+                              generate_regex_from_string)\n+from helper.util import (get_page, transform_from_normalized,\n+                         transform_from_normalized_coords_object)\n from logger import get_logger\n-from models import (\n-    DocOriginRules,\n-    FellowKVRule,\n-    FellowKVRuleUser,\n-    FellowKVSourceFile,\n-    FellowKVTableColumnRule,\n-    FellowKVTableRule,\n-    TableFormattingRules,\n-    TfidfDocs,\n-)\n+from models import (DocOriginRules, FellowKVRule, FellowKVRuleUser,\n+                    FellowKVSourceFile, FellowKVTableColumnRule,\n+                    FellowKVTableRule, TableFormattingRules, TfidfDocs)\n \n logger = get_logger(\"plugin-export-util\")\n \n@@ -690,15 +681,18 @@ def create_table_rules_in_db(docs, user, is_new=False):\n                     )\n \n                     formatting_rules_id = str(uuid.uuid4())\n+                    rule_columns = rule.get(\"columns\", [\"\"])\n+                    if rule_columns == None:\n+                        rule_columns = [\"\"]\n                     if table_formatting_rule:\n                         formatting_rules_id = table_formatting_rule.id\n                         table_formatting_rule.ruleWeight = (\n                             table_formatting_rule.ruleWeight + 1\n                         )\n+                        table_formatting_rule.columns = rule_columns[0]\n+                        # update column locations because we dont use these in where clause\n+                        # so they didnt get updated on change.\n                     else:\n-                        rule_columns = rule.get(\"columns\", [\"\"])\n-                        if rule_columns == None:\n-                            rule_columns = [\"\"]\n                         table_formatting_rule = TableFormattingRules()\n                         table_formatting_rule.id = formatting_rules_id\n                         table_formatting_rule.docType = docType\n@@ -750,8 +744,8 @@ def create_table_rules_in_db(docs, user, is_new=False):\n                         table_formatting_rule.user_id = user_id\n                         table_formatting_rule.org_id = org_id\n                         db.session.add(table_formatting_rule)\n-                        db.session.commit()\n-                        db.session.refresh(table_formatting_rule)\n+                    db.session.commit()\n+                    db.session.refresh(table_formatting_rule)\n \n                 record = None\n                 if rule.get(\"rule_id\"):",
      "code_change_description": "Refactored import statements and removed unused imports. Also simplified some code blocks by removing unnecessary conditions and variables.",
      "code_smell_rating": 3,
      "github_labels": ["refactor"]
    },
    {
      "sha": "3312c74bdcce6b9183e37a435c6ca5db8c2b628f",
      "message": "Merge pull request #785 from Fellow-Consulting-AG/stage\n\nStage",
      "code_changes": "@@ -4,7 +4,7 @@\n def get_lov_values(org_id, key):\n     query = f\"\"\"\n         Select\n-            value, org_id\n+            value, org_id, synonyms\n         From\n             lov_list_of_value llov\n         Where",
      "code_change_description": "The code has been modified to include the 'synonyms' field in the SELECT statement of the SQL query. This will allow the API to return a list of synonyms associated with each value in the LOV.",
      "code_smell_rating": 3,
      "github_labels": ["enhancement"]
    },
    {
      "sha": "af9f9ba316f5bccf80f001e60b639c89241680e1",
      "message": "Merge pull request #783 from Fellow-Consulting-AG/dev\n\nfd",
      "code_changes": "@@ -4,7 +4,7 @@\n def get_lov_values(org_id, key):\n     query = f\"\"\"\n         Select\n-            value, org_id\n+            value, org_id, synonyms\n         From\n             lov_list_of_value llov\n         Where",
      "code_change_description": "The code has been modified to include the 'synonyms' field in the SELECT statement of the SQL query. This will allow the API to return a list of synonyms associated with each value in the LOV.",
      "code_smell_rating": 3,
      "github_labels": ["enhancement"]
    },
    {
      "sha": "e329af08ea5147f4d5abc4e33f51e22aedeb8589",
      "message": "fd",
      "code_changes": "@@ -16,31 +16,6 @@\n namespace = Namespace(\"List of values\", description=\"List of values\")\n \n \n-@namespace.route(\"/lov_list\", methods=[\"GET\"])\n-@namespace.doc(\n-    params={\n-        \"Authorization\": {\n-            \"in\": \"header\",\n-            \"description\": \"Authorization: Bearer <access_token>\",\n-        }\n-    }\n-)\n-class GetLovTypes(Resource):\n-    @multi_auth.login_required\n-    @namespace.doc(\"Get List Of Values Types\")\n-    def get(self):\n-        try:\n-            user = multi_auth.current_user()\n-            org_id = user.get_org_id()\n-            values = get_lov_values(org_id, \"LOV_TYPE\")\n-            return {\"success\": True, \"data\": values}\n-        except Exception as ex:\n-            return {\n-                \"success\": False,\n-                \"message\": repr(ex) + \"\\n\" + traceback.format_exc(),\n-            }\n-\n-\n aiparser = api.parser()\n aiparser.add_argument(\"name\", type=str, required=True, location=\"form\")\n "
    },
    {
      "sha": "e2c8efbd022c41910dcab3769dfb3a2044f5ff55",
      "message": "fd",
      "code_changes": "@@ -4,7 +4,7 @@\n def get_lov_values(org_id, key):\n     query = f\"\"\"\n         Select\n-            value, org_id\n+            value, org_id, synonyms\n         From\n             lov_list_of_value llov\n         Where",
      "code_change_description": "The code has been modified to include the 'synonyms' field in the SELECT statement of the SQL query. This will allow the API to return a list of synonyms associated with each value in the LOV.",
      "code_smell_rating": 3,
      "github_labels": ["enhancement"]
    }
  ]
}
