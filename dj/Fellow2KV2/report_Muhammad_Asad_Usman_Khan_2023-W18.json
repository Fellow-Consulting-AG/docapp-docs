{
    "author": "Muhammad Asad Usman Khan",
    "week": "2023-W18",
    "total_commits": 7,
    "author_image": "https://avatars.githubusercontent.com/u/83513548?v=4",
    "commits": [
        {
            "sha": "72050a45186a059f01c4c20582054732993189a4",
            "message": "Merge pull request #888 from Fellow-Consulting-AG/dev\n\nfd",
            "code_changes": "@@ -68,15 +68,15 @@ def get_ocr_text(file):\n \n @sync_wrapper(module=\"ocr\")\n def get_pages_to_ocr(file):\n-    \"\"\"\n-    Extract text using OCR with PDF Reader\n-    Args:\n-        file: write your description\n-    \"\"\"\n     pages = []\n     try:\n-        logger.info(\"Trying if document has e-text\")\n+        logger.info(\"Getting the pages required to be ocr\")\n         with fitz.open(file) as doc:\n+            try:\n+                if doc.metadata['creator'].lower() == 'pscript5.dll version 5.2.2':\n+                    return \"ALL\"\n+            except:\n+                pass\n             for index, page in enumerate(doc):\n                 if not page_digitally_created(page):\n                     pages.append(str(index + 1))\n@@ -163,6 +163,8 @@ def __get_ocr_file(\n \n     files = [(\"file\", (\"Rechnung.pdf\", open(file, \"rb\"), \"application/pdf\"))]\n     pages = get_pages_to_ocr(file)\n+    if not pages:\n+        pages = \"ALL\"\n     token = user.get_subscription_token()\n \n     logger.info(\"Sending ocr request.\")\n@@ -181,7 +183,7 @@ def __get_ocr_file(\n             headers={\"Authorization\": f\"Bearer {token}\"},\n             files=files,\n             data={\n-                \"force\": False,\n+                \"force\": True,\n                 \"deskew\": False,\n                 \"clean\": False,\n                 \"final\": False,"
        },
        {
            "sha": "f4c5fda44852ad6b75659a3ec4b561b3b5dbc211",
            "message": "fd",
            "code_changes": "@@ -68,15 +68,15 @@ def get_ocr_text(file):\n \n @sync_wrapper(module=\"ocr\")\n def get_pages_to_ocr(file):\n-    \"\"\"\n-    Extract text using OCR with PDF Reader\n-    Args:\n-        file: write your description\n-    \"\"\"\n     pages = []\n     try:\n-        logger.info(\"Trying if document has e-text\")\n+        logger.info(\"Getting the pages required to be ocr\")\n         with fitz.open(file) as doc:\n+            try:\n+                if doc.metadata['creator'].lower() == 'pscript5.dll version 5.2.2':\n+                    return \"ALL\"\n+            except:\n+                pass\n             for index, page in enumerate(doc):\n                 if not page_digitally_created(page):\n                     pages.append(str(index + 1))\n@@ -163,6 +163,8 @@ def __get_ocr_file(\n \n     files = [(\"file\", (\"Rechnung.pdf\", open(file, \"rb\"), \"application/pdf\"))]\n     pages = get_pages_to_ocr(file)\n+    if not pages:\n+        pages = \"ALL\"\n     token = user.get_subscription_token()\n \n     logger.info(\"Sending ocr request.\")\n@@ -181,7 +183,7 @@ def __get_ocr_file(\n             headers={\"Authorization\": f\"Bearer {token}\"},\n             files=files,\n             data={\n-                \"force\": False,\n+                \"force\": True,\n                 \"deskew\": False,\n                 \"clean\": False,\n                 \"final\": False,"
        },
        {
            "sha": "5bf21456c6db7b8fd6c72f44d2d454c3df795584",
            "message": "Merge pull request #886 from Fellow-Consulting-AG/dev\n\nfd",
            "code_changes": "@@ -47,6 +47,11 @@ def get_ocr_text(file):\n     try:\n         logger.info(\"Trying if document has e-text\")\n         with fitz.open(file) as doc:\n+            try:\n+                if doc.metadata['creator'].lower() == 'pscript5.dll version 5.2.2':\n+                    return \"\"\n+            except:\n+                pass\n             for page in doc:\n                 if not page_digitally_created(page):\n                     return \"\"\n@@ -208,7 +213,7 @@ def __get_ocr_file(\n             )\n             urllib.request.urlretrieve(durl, f.name)\n             f.seek(0)\n-        logger.customer(\"OCRed Document saved successfully\")\n+        logger.customer(\"OCR completed successfully. The new OCRed document has been saved at: \" + destination)\n     else:\n         if with_cleaning:\n             return __get_ocr_file(\n@@ -267,15 +272,15 @@ def page_digitally_created(page):\n     page_area = abs(page.rect)  # Total page area\n \n     img_area = 0.0\n-    for block in page.getText(\"RAWDICT\")[\"blocks\"]:\n+    for block in page.get_text(\"RAWDICT\")[\"blocks\"]:\n         if block[\"type\"] == 1:  # Type=1 are images\n             bbox = block[\"bbox\"]\n             img_area += (bbox[2] - bbox[0]) * (bbox[3] - bbox[1])  # width*height\n     img_perc = img_area / page_area\n     # print(\"Image area proportion: \" + str(img_perc))\n \n     text_area = 0.0\n-    for b in page.getTextBlocks():\n+    for b in page.get_text_blocks():\n         r = fitz.Rect(b[:4])  # Rectangle where block text appears\n         text_area = text_area + abs(r)\n     text_perc = text_area / page_area"
        },
        {
            "sha": "c521c001cf761a714c296e65d7cb61fc25a207c1",
            "message": "CLOU-5187",
            "code_changes": "@@ -47,6 +47,11 @@ def get_ocr_text(file):\n     try:\n         logger.info(\"Trying if document has e-text\")\n         with fitz.open(file) as doc:\n+            try:\n+                if doc.metadata['creator'].lower() == 'pscript5.dll version 5.2.2':\n+                    return \"\"\n+            except:\n+                pass\n             for page in doc:\n                 if not page_digitally_created(page):\n                     return \"\""
        },
        {
            "sha": "f9ec6004754eb5d7854aefb64217a3c7cd8ab6fc",
            "message": "fd",
            "code_changes": "@@ -267,15 +267,15 @@ def page_digitally_created(page):\n     page_area = abs(page.rect)  # Total page area\n \n     img_area = 0.0\n-    for block in page.getText(\"RAWDICT\")[\"blocks\"]:\n+    for block in page.get_text(\"RAWDICT\")[\"blocks\"]:\n         if block[\"type\"] == 1:  # Type=1 are images\n             bbox = block[\"bbox\"]\n             img_area += (bbox[2] - bbox[0]) * (bbox[3] - bbox[1])  # width*height\n     img_perc = img_area / page_area\n     # print(\"Image area proportion: \" + str(img_perc))\n \n     text_area = 0.0\n-    for b in page.getTextBlocks():\n+    for b in page.get_text_blocks():\n         r = fitz.Rect(b[:4])  # Rectangle where block text appears\n         text_area = text_area + abs(r)\n     text_perc = text_area / page_area"
        },
        {
            "sha": "268b74cc9e9fddec8c947d09403010bc2fff5f50",
            "message": "Merge pull request #884 from Fellow-Consulting-AG/dev\n\nfd",
            "code_changes": "@@ -1,13 +1,13 @@\n # venv image\n-#FROM ubuntu:20.04 as venv-image\n-FROM python:3.9.16-bullseye as venv-image\n+FROM ubuntu:20.04 as venv-image\n+# FROM python:3.9.16-bullseye as venv-image\n \n-# RUN apt update\n-# RUN apt install -y software-properties-common\n+RUN apt update\n+RUN apt install -y software-properties-common\n \n-# RUN add-apt-repository ppa:deadsnakes/ppa\n+RUN add-apt-repository ppa:deadsnakes/ppa\n \n-# RUN apt install -y python3.9 python3.9-venv\n+RUN apt install -y python3.9 python3.9-venv\n \n \n \n@@ -27,15 +27,15 @@ RUN pip3 install gunicorn opencv-python camelot-py[all] uvicorn\n \n \n # debian custom image\n-#FROM ubuntu:20.04 as base-image\n-FROM python:3.9.16-bullseye as base-image\n+FROM ubuntu:20.04 as base-image\n+# FROM python:3.9.16-bullseye as base-image\n \n-# RUN apt update\n-# RUN apt install -y software-properties-common\n+RUN apt update\n+RUN apt install -y software-properties-common\n \n-# RUN add-apt-repository ppa:deadsnakes/ppa\n+RUN add-apt-repository ppa:deadsnakes/ppa\n \n-# RUN apt install -y python3.9\n+RUN apt install -y python3.9\n \n \n "
        },
        {
            "sha": "0140c041260d32ac32fe1a7984dbabd39a8ce5e3",
            "message": "fd",
            "code_changes": "@@ -8,14 +8,17 @@\n import traceback\n from datetime import datetime\n \n+import img2pdf\n from flask import jsonify, request, send_file\n from flask_restx import Namespace, Resource, abort\n+from pdf2image import convert_from_path\n from werkzeug.datastructures import FileStorage\n \n import constants\n import helper.ocr as ocr_helper\n from authenticator import UserAuthentication\n-from fellow2kv.extension import api, db, multi_auth, storagemanager, storagemanager_doc2\n+from fellow2kv.extension import (api, db, multi_auth, storagemanager,\n+                                 storagemanager_doc2)\n from helper import doc_type_helper as dth\n from helper import generic_data_vault_helper as gdvh\n from helper import pdf as pdf_helper\n@@ -24,11 +27,8 @@\n from helper.document_classifier import document_classifier\n from helper.document_extraction import document_extraction_helper as deh\n from helper.extract_util import Extractor\n-from helper.util import (\n-    str_to_bool,\n-    transform_from_normalized_coords_object,\n-    transform_to_normalized,\n-)\n+from helper.util import (str_to_bool, transform_from_normalized_coords_object,\n+                         transform_to_normalized)\n from logger import get_logger\n from util import sync_wrapper\n \n@@ -37,6 +37,7 @@\n doc2_base_directory = \"documents\"\n \n \n+\n aiparser = api.parser()\n aiparser.add_argument(\"doc_id\", type=str, required=True, location=\"form\")\n aiparser.add_argument(\"doc_path\", type=str, required=False, location=\"form\")\n@@ -202,6 +203,7 @@ def post(self):\n                         )  # no point in OCR again if already done with doc2\n                     )\n                     or improve_quality\n+                    or disable_ocr_server # right now for medi to fix inverted documents\n                 ):\n                     ocr_helper.ocr_document(\n                         user,\n@@ -885,3 +887,145 @@ def get(self, doc_id, filename):\n             )\n         except:\n             abort(404)\n+\n+\n+\n+aiparser = api.parser()\n+\n+aiparser.add_argument(\"extracted_data\", type=str, required=False, location=\"form\")\n+@namespace.route(\"/hussain\", methods=[\"POST\"])\n+@namespace.doc(\n+    params={\n+        \"Authorization\": {\n+            \"in\": \"header\",\n+            \"description\": \"Authorization: Bearer <access_token>\",\n+        }\n+    }\n+)\n+class Hussain(Resource):\n+    @namespace.expect(aiparser)\n+    @multi_auth.login_required\n+    @namespace.doc(\"Mock process the document to extract fields and tables\")\n+    def post(self):\n+        \"\"\"\n+        TODO: How extraction will work\n+\n+        - It will be checked if ocr data has been extracted and document\n+        has been classified or not.\n+        - Document will be classified\n+        - Document fields and tables information will be populated\n+        - Fields will be extracted\n+        - Table will be extracted. Only V3 from now on.\n+        - Validation for the fields and table, we can keep in doc2api for now\n+        \"\"\"\n+\n+        request_data = request.form\n+        user: UserAuthentication = multi_auth.current_user()\n+        org_id = user.get_org_id()\n+\n+\n+        jpegopt = {\"quality\": 100, \"progressive\": True}\n+        annotations_path = f\"debugging/ocr_json/annotations/\"\n+        if not os.path.exists(annotations_path):\n+            os.makedirs(annotations_path)\n+        images_path = f\"debugging/ocr_json/images/\"\n+        if not os.path.exists(images_path):\n+            os.makedirs(images_path)\n+        pdf_path = f\"debugging/ocr_json/pdf/\"\n+        if not os.path.exists(pdf_path):\n+            os.makedirs(pdf_path)\n+\n+        export_data = json.loads(request.form.get(\"data\", \"[]\"))\n+        \n+        for item in export_data:\n+            try:\n+                if not item['tables'] or not item['tables'][0]['rows']:\n+                    continue\n+                doc_id = item['id']\n+                table = item['tables'][0]\n+                document = json.loads(\n+                    storagemanager_doc2.get_file_content(\n+                        f\"documents/{doc_id}/{doc_id}_ai_transform.json\"\n+                    ).decode(\"UTF-8\")\n+                )\n+                ai_extractor = Extractor(document, \"\", 0)\n+                coords_object = {}\n+                for location in table['locations']:\n+                    for page in document[\"pages\"]:\n+                        if int(page[\"pageNumber\"]) == location['page']:\n+                            page_to_use = page\n+                            break\n+\n+                    height = page_to_use[\"height\"]\n+                    width = page_to_use[\"width\"]\n+                    coords_object[str(location['page'])] = {\n+                        \"x0\": round(float(location['coords'][0]) * width), \n+                        \"x1\": round(float(location['coords'][1]) * height), \n+                        \"y0\": round(float(location['coords'][2]) * width), \n+                        \"y1\": round(float(location['coords'][3]) * height)\n+                    }\n+                    lines, last_line_found = ai_extractor.get_custom_lines_from_coordinates(\n+                        coords_object[str(location['page'])], location['page'] - 1\n+                    )\n+\n+                form = []\n+                for row in table['rows']:\n+                    for page in document[\"pages\"]:\n+                        if int(page[\"pageNumber\"]) == row['locations'][0]['page']:\n+                            page_to_use = page\n+                            break\n+\n+                    height = page_to_use[\"height\"]\n+                    width = page_to_use[\"width\"]\n+                    box = [\n+                        round(float(row['locations'][0]['coords'][0]) * width),\n+                        round(float(row['locations'][0]['coords'][1]) * height),\n+                        round(float(row['locations'][0]['coords'][2]) * width),\n+                        round(float(row['locations'][0]['coords'][3]) * height),\n+                    ]\n+\n+                    words = [\n+                        {\n+                            \"text\": row['content'],\n+                            \"box\": box\n+                        }\n+                    ]\n+                    \n+                    row_object = {\n+                        \"text\": row['content'],\n+                        \"label\": \"TABLE BODY\",\n+                        \"box\": box,\n+                        \"words\": words,\n+                        \"linking\": [],\n+                        \"id\": len(form) + 1\n+                    }\n+                    form.append(row_object)\n+\n+                \n+\n+                json_object = {\n+                    \"documentName\": f\"{doc_id}.pdf\",\n+                    \"document\": document['tfidfCustomPageText'],\n+                    \"form\": form\n+                }\n+                doc_path = f\"documents/{doc_id}/{doc_id}.pdf\"\n+                with open(f\"{annotations_path}{doc_id}.json\", \"w\") as outfile:\n+                    outfile.write(json.dumps([json_object], indent=4))\n+                with tempfile.TemporaryDirectory() as tmp_dir:\n+                    with tempfile.NamedTemporaryFile() as tf:\n+                        storagemanager_doc2.download_file_on_stream(tf, doc_path)\n+                        images = convert_from_path(\n+                            tf.name, dpi=300, output_folder=tmp_dir,fmt='jpeg', jpegopt=jpegopt\n+                        )\n+\n+                        for index, img_path in enumerate(images):\n+                            with open(f\"{pdf_path}{doc_id}_{index+1}.pdf\", \"wb\") as out_file:\n+                                out_file.write(img2pdf.convert([img_path.filename]))\n+                            img_path.save(f'{images_path}{doc_id}_{index+1}.jpg', 'JPEG')\n+\n+\n+                \n+                print(json.dumps(json_object))\n+            except Exception as ex:\n+                print(f\"An Error occurred. Message: {ex}\")\n+                continue\n\\ No newline at end of file"
        }
    ]
}